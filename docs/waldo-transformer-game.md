# Waldo Transformer Game

## The Board

The playing board has four components:
* a set (possibly empty) of grids defining the problem setup 
* a generator clan, which is always a complete, executable `Mix` subclass
* two "waldos" W1 and w2 that each point to a role of a `Mix` in the generator clan (and sometimes to an index
  of the role's list value)
* three work-in-progress grids:
  * the grid generated by the generator clan
  * for each waldo, the grid generated by the generator clan with rendering suppressed outside 
    the sept pointed to by the waldo
    
The starting position supplies a simple/stupid no-op generator clan. E.g. it may construct a grid of zero 
size and then render no Shapes into it.
    
## The Moves
    
There are three kinds of moves (actions):

* Move a waldo: These can be simple, mechanical tree moves (like "move to the parent role") or
  more conceptual navigation (like move to the first shape contained in the current role).
  
* Apply a transformation to either waldo or across the two waldos.

  * Examples of single-waldo transformations:
    * Re-parent this Shape with a ShapeGroup.
    * Re-parent this Shape with a Rotation.
    * Replace this Dot with a Line of length 1.
    * Append a ______ to this List<Shape>.
    
  * Examples of two-waldo transformations:
    * Swap the septs at the two waldo positions.
    * Replace the W1 sept with a ShapeGroup that contains the original W1 sept and the W2 sept (which is deleted from
      its original location).
    * Given that W1 and W2 point at indices in the same List<Shape> role, 
      replace the Shapes from W1 to W2 inclusive with a ShapeGroup containing those Shapes.
      
* Mark the position as either a step toward the solution (such as a proposed input grid, if the problem
  is to generate an input/output grid pair) or as the complete solution.
      
In the style of AlphaZero's chess move representation, the set of potential moves is a fixed enumeration, baked 
into a model's training environment.

## The Predictions 

At each board position, the model is asked to predict a value and a policy.

The value of a position is 0.0 if no correct solution is reached from that position. Else it is 1.0 discounted by
the distance to the nearest correct solution. The actual value of a position resulting from an illegal move is 
always 0.0. (So, in essence, there is a single, distinguished board position reached by every illegal move.
One might call this position "Oops".) 

The policy for a position is a probability for each potential move,
representing the likelihood of that move leading to a correct solution. 

## Problems

Except where otherwise specified, each problem below is solved using the same general game structure
proposed above. For example, when the problem is stated as "Generate a plausible input grid.", the intended
approach is to create a transformation from the simple/stupid generator to a generator that renders a plausible
input grid.

The ordering here is partly from easiest to hardest, but also partly reflects the order in which we'd need to
develop problem-solvers to assemble them into a complete ARC solver.

### Generate a plausible input grid.

This problem is used to train a
[critter](https://docs.google.com/document/d/1vouA9qZjAZxhFV8VbtkCZytrkFw_83D00P7rU9xRVes/edit#heading=h.1buw2oqbius)
to randomly generate input grids that are "plausible" relative to the ARC training data. The critter is trained by
treating it as the generative "network" in a [Generative Adversarial Network (GAN)](). The discriminative network
is in fact a DNN, whose job is to try to distinguish between randomly generated "counterfeit" input grids and
"real" input grids from the ARC training data.

### Generate a plausible input/output grid pair.

This problem extends "generate a plausible input grid" by requiring the critter to continue beyond its proposed
input grid, transforming further into a proposed corresponding output grid. The resulting critter is able to 
create infinite training data for certain other problems, below.

### Reconstruct the transformation sequence for this input/output grid pair.

The correct solution for this problem is a transformation sequence that generates first the given input grid
and then the given output grid. The critter is trained against data generated by
"Generate a plausible input/output grid pair."

### Given an input/output generator pair, generate a plausible additional input/output pair for the same task.

This problem takes two inputs:
* an input grid's generator
* a transformer sequence from that generator to the output grid's generator

The output is a transformer sequence that converts the input grid's generator into the generator
for a plausible second input grid of the same task. The given input-to-output transformer is then
automatically applied to this new generator to create the corresponding output grid.

This critter is trained in GAN style, against a DNN that tries to distinguish "counterfeit" from "real"
sets of two input/output pairs that are alleged to come from the same real task. 

The resulting critter is able to generate infinite training data for "Solve an ARC task".

### Solve an ARC task.

Given an ARC task, construct the solution.

This critter is trained against a combination of real ARC tasks and counterfeits generated using 
* Generate a plausible input/output grid pair.
* Given an input/output generator pair, generate a plausible additional input/output pair for the same task.








 